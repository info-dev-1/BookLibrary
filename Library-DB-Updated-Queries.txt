import java.sql.*;
import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
//import java.util.ArrayList;
//import java.util.List;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

public class Library {
    private Connection connection;

    public Library() {
        try {
            connection = DriverManager.getConnection("jdbc:sqlite:library.db");
        } catch (SQLException e) {
            System.out.println("Failed to connect to database: " + e.getMessage());
        }
    }

    // Close connection upon application exit
    public void close() {
        try {
            if (connection != null) connection.close();
        } catch (SQLException e) {
            System.out.println("Error closing connection: " + e.getMessage());
        }
    }

    // Feature: Authentication for Librarians and Patrons Login
    public String authenticate(String username, String password, String role) {  // role: "librarian" or "patron"
        String table = role.equals("librarian") ? "librarians" : "patrons";
        String sql = "SELECT id, hashed_password FROM " + table + " WHERE username = ?";
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, username);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) {
                String storedHash = rs.getString("hashed_password");
                if (hashPassword(password).equals(storedHash)) {
                    return rs.getString("id");  // Return user ID as String for simplicity
                }
            }
        } catch (SQLException e) {
            System.out.println("Authentication error: " + e.getMessage());
        }
        return null;
    }

    private String hashPassword(String password) {
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            byte[] hashBytes = md.digest(password.getBytes());
            StringBuilder sb = new StringBuilder();
            for (byte b : hashBytes) {
                sb.append(String.format("%02x", b));
            }
            return sb.toString();
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("Hashing error: " + e.getMessage());
        }
    }

    // Display Books (Queries Database)
    public void displayBooks() {
        String sql = "SELECT b.id, b.title, b.author, b.isbn, b.genre, b.available, p.name AS borrowed_by, c.due_date " +
                     "FROM books b LEFT JOIN checkouts c ON b.id = c.book_id AND c.return_date IS NULL " +
                     "LEFT JOIN patrons p ON c.patron_id = p.id";
        try (Statement stmt = connection.createStatement(); ResultSet rs = stmt.executeQuery(sql)) {
            System.out.println("Books in the library:");
            while (rs.next()) {
                String status = rs.getInt("available") == 1 ? "Available: Yes" : 
                                "Available: No, Borrowed By: " + rs.getString("borrowed_by") + ", Due Date: " + rs.getString("due_date");
                System.out.println("ID: " + rs.getInt("id") + ", Title: " + rs.getString("title") + 
                                   ", Author: " + rs.getString("author") + ", ISBN: " + rs.getString("isbn") + 
                                   ", Genre: " + rs.getString("genre") + ", " + status);
            }
        } catch (SQLException e) {
            System.out.println("Error displaying books: " + e.getMessage());
        }
    }

    // Display Patrons (Queries Database)
    public void displayPatrons() {
        String sql = "SELECT id, name, email, phone FROM patrons";
        try (Statement stmt = connection.createStatement(); ResultSet rs = stmt.executeQuery(sql)) {
            System.out.println("Patrons in the library:");
            while (rs.next()) {
                System.out.println("ID: " + rs.getInt("id") + ", Name: " + rs.getString("name") + 
                                   ", Email: " + rs.getString("email") + ", Phone: " + rs.getString("phone"));
            }
        } catch (SQLException e) {
            System.out.println("Error displaying patrons: " + e.getMessage());
        }
    }

    // Borrow Book (Updates Checkouts and Books)
    public void borrowBook(int bookId, int patronId) {
        String checkSql = "SELECT available FROM books WHERE id = ?";
        try (PreparedStatement checkStmt = connection.prepareStatement(checkSql)) {
            checkStmt.setInt(1, bookId);
            ResultSet rs = checkStmt.executeQuery();
            if (rs.next() && rs.getInt("available") == 1) {
                LocalDate checkoutDate = LocalDate.now();
                LocalDate dueDate = checkoutDate.plusDays(14);
                String insertSql = "INSERT INTO checkouts (patron_id, book_id, checkout_date, due_date, return_date) VALUES (?, ?, ?, ?, NULL)";
                try (PreparedStatement insertStmt = connection.prepareStatement(insertSql)) {
                    insertStmt.setInt(1, patronId);
                    insertStmt.setInt(2, bookId);
                    insertStmt.setString(3, checkoutDate.toString());
                    insertStmt.setString(4, dueDate.toString());
                    insertStmt.executeUpdate();
                }
                String updateSql = "UPDATE books SET available = 0 WHERE id = ?";
                try (PreparedStatement updateStmt = connection.prepareStatement(updateSql)) {
                    updateStmt.setInt(1, bookId);
                    updateStmt.executeUpdate();
                    System.out.println("Book borrowed successfully. Due Date: " + dueDate);
                }
            } else {
                System.out.println("Book not available.");
            }
        } catch (SQLException e) {
            System.out.println("Error borrowing book: " + e.getMessage());
        }
    }

    // Return Book (Updates Checkouts and Books, Checks for Holds)
    public void returnBook(int bookId) {
        String checkSql = "SELECT id FROM checkouts WHERE book_id = ? AND return_date IS NULL";
        try (PreparedStatement checkStmt = connection.prepareStatement(checkSql)) {
            checkStmt.setInt(1, bookId);
            ResultSet rs = checkStmt.executeQuery();
            if (rs.next()) {
                int checkoutId = rs.getInt("id");
                String updateCheckoutSql = "UPDATE checkouts SET return_date = ? WHERE id = ?";
                try (PreparedStatement updateStmt = connection.prepareStatement(updateCheckoutSql)) {
                    updateStmt.setString(1, LocalDate.now().toString());
                    updateStmt.setInt(2, checkoutId);
                    updateStmt.executeUpdate();
                }
                String updateBookSql = "UPDATE books SET available = 1 WHERE id = ?";
                try (PreparedStatement updateStmt = connection.prepareStatement(updateBookSql)) {
                    updateStmt.setInt(1, bookId);
                    updateStmt.executeUpdate();
                }
                // Check for Holds and Update First Pending to 'Ready Status'
                String holdSql = "UPDATE holds SET status = 'ready' WHERE book_id = ? AND status = 'pending' LIMIT 1";
                try (PreparedStatement holdStmt = connection.prepareStatement(holdSql)) {
                    holdStmt.setInt(1, bookId);
                    holdStmt.executeUpdate();
                }
                // Calculate and insert fine if overdue
                calculateAndInsertFine(checkoutId);
                System.out.println("Book returned successfully.");
            } else {
                System.out.println("Book not borrowed.");
            }
        } catch (SQLException e) {
            System.out.println("Error returning book: " + e.getMessage());
        }
    }

    private void calculateAndInsertFine(int checkoutId) {
        String sql = "SELECT due_date, return_date FROM checkouts WHERE id = ?";
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setInt(1, checkoutId);
            ResultSet rs = stmt.executeQuery();
            if (rs.next()) {
                LocalDate dueDate = LocalDate.parse(rs.getString("due_date"));
                LocalDate returnDate = LocalDate.parse(rs.getString("return_date"));
                if (returnDate.isAfter(dueDate)) {
                    long daysOverdue = ChronoUnit.DAYS.between(dueDate, returnDate);
                    double amount = daysOverdue * 0.25;
                    String insertSql = "INSERT INTO fines (patron_id, checkout_id, amount, paid) " +
                                       "SELECT patron_id, ?, ?, 0 FROM checkouts WHERE id = ?";
                    try (PreparedStatement insertStmt = connection.prepareStatement(insertSql)) {
                        insertStmt.setInt(1, checkoutId);
                        insertStmt.setDouble(2, amount);
                        insertStmt.setInt(3, checkoutId);
                        insertStmt.executeUpdate();
                    }
                }
            }
        } catch (SQLException e) {
            System.out.println("Error calculating fine: " + e.getMessage());
        }
    }

    // Feature: Overdue Book Notifications & Fines Tracking
    public void displayOverdueAndFines() {
        String sql = "SELECT c.id, b.title, p.name, c.due_date, f.amount, f.paid " +
                     "FROM checkouts c JOIN books b ON c.book_id = b.id " +
                     "JOIN patrons p ON c.patron_id = p.id " +
                     "LEFT JOIN fines f ON c.id = f.checkout_id " +
                     "WHERE c.return_date IS NULL AND c.due_date < ?";
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, LocalDate.now().toString());
            ResultSet rs = stmt.executeQuery();
            System.out.println("Overdue Books and Fines:");
            while (rs.next()) {
                double fine = rs.getDouble("amount");
                if (fine == 0) {  // Calculate on-the-fly if no fine record
                    LocalDate dueDate = LocalDate.parse(rs.getString("due_date"));
                    long daysOverdue = ChronoUnit.DAYS.between(dueDate, LocalDate.now());
                    fine = daysOverdue * 0.25;
                }
                String paidStatus = rs.getInt("paid") == 1 ? "Paid" : "Unpaid";
                System.out.println("Checkout ID: " + rs.getInt("id") + ", Book: " + rs.getString("title") + 
                                   ", Patron: " + rs.getString("name") + ", Due: " + rs.getString("due_date") + 
                                   ", Fine: $" + fine + " (" + paidStatus + ")");
            }
        } catch (SQLException e) {
            System.out.println("Error displaying overdues: " + e.getMessage());
        }
    }

    // Feature: Book Reservation / Hold System
    public void reserveBook(int bookId, int patronId) {
        String checkSql = "SELECT available FROM books WHERE id = ?";
        try (PreparedStatement checkStmt = connection.prepareStatement(checkSql)) {
            checkStmt.setInt(1, bookId);
            ResultSet rs = checkStmt.executeQuery();
            if (rs.next() && rs.getInt("available") == 0) {  // Only reserve if checked out
                String insertSql = "INSERT INTO holds (patron_id, book_id, request_date, status) VALUES (?, ?, ?, 'pending')";
                try (PreparedStatement insertStmt = connection.prepareStatement(insertSql)) {
                    insertStmt.setInt(1, patronId);
                    insertStmt.setInt(2, bookId);
                    insertStmt.setString(3, LocalDate.now().toString());
                    insertStmt.executeUpdate();
                    System.out.println("Book reserved successfully.");
                }
            } else {
                System.out.println("Book is availableâ€”no need to reserve.");
            }
        } catch (SQLException e) {
            System.out.println("Error reserving book: " + e.getMessage());
        }
    }

    // Feature: Borrowing History per Patron
    public void displayBorrowingHistory(int patronId) {
        String sql = "SELECT b.title, c.checkout_date, c.due_date, c.return_date, " +
                     "CASE WHEN c.return_date IS NULL AND c.due_date < ? THEN 'Overdue' ELSE 'On Time' END AS status " +
                     "FROM checkouts c JOIN books b ON c.book_id = b.id WHERE c.patron_id = ?";
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, LocalDate.now().toString());
            stmt.setInt(2, patronId);
            ResultSet rs = stmt.executeQuery();
            System.out.println("Borrowing History:");
            while (rs.next()) {
                String returnDate = rs.getString("return_date") != null ? rs.getString("return_date") : "Not Returned";
                System.out.println("Book: " + rs.getString("title") + ", Checkout: " + rs.getString("checkout_date") + 
                                   ", Due: " + rs.getString("due_date") + ", Returned: " + returnDate + 
                                   ", Status: " + rs.getString("status"));
            }
        } catch (SQLException e) {
            System.out.println("Error displaying history: " + e.getMessage());
        }
    }

    // Librarian Feature: Add Book, Remove Book, Add Patron and Remove Patron
    public void addBook(String title, String author, String isbn, String genre) {
        String sql = "INSERT INTO books (title, author, isbn, genre, available) VALUES (?, ?, ?, ?, 1)";
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setString(1, title);
            stmt.setString(2, author);
            stmt.setString(3, isbn);
            stmt.setString(4, genre);
            stmt.executeUpdate();
            System.out.println("Book added successfully.");
        } catch (SQLException e) {
            System.out.println("Error adding book: " + e.getMessage());
        }
    }

public void removeBook(int bookId) {
    // Check if book is borrowed
    String checkSql = "SELECT available FROM books WHERE id = ?";
    try (PreparedStatement checkStmt = connection.prepareStatement(checkSql)) {
        checkStmt.setInt(1, bookId);
        ResultSet rs = checkStmt.executeQuery();
        if (rs.next() && rs.getInt("available") == 0) {
            System.out.println("Cannot remove borrowed book.");
            return;
        }
    } catch (SQLException e) {
        System.out.println("Error checking book: " + e.getMessage());
        return;
    }


    // Remove Related Records (Checkouts, Fines, Holds)
    String[] deleteSqls = {
        "DELETE FROM fines WHERE checkout_id IN (SELECT id FROM checkouts WHERE book_id = ?)",
        "DELETE FROM holds WHERE book_id = ?",
        "DELETE FROM checkouts WHERE book_id = ?",
        "DELETE FROM books WHERE id = ?"
    };
    for (String sql : deleteSqls) {
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setInt(1, bookId);
            stmt.executeUpdate();
        } catch (SQLException e) {
            System.out.println("Error removing book data: " + e.getMessage());
            return;
        }
    }
    System.out.println("Book removed successfully.");
}

// Add / Remove Patron

public void addPatron(String name, String email, String phone, String username, String password) {
    String hashedPassword = hashPassword(password);
    String sql = "INSERT INTO patrons (name, email, phone, username, hashed_password) VALUES (?, ?, ?, ?, ?)";
    try (PreparedStatement stmt = connection.prepareStatement(sql)) {
        stmt.setString(1, name);
        stmt.setString(2, email);
        stmt.setString(3, phone);
        stmt.setString(4, username);
        stmt.setString(5, hashedPassword);
        stmt.executeUpdate();
        System.out.println("Patron added successfully.");
    } catch (SQLException e) {
        System.out.println("Error adding patron: " + e.getMessage());
    }
}

public void removePatron(int patronId) {
    // First, check if patron has active checkouts or holds
    String checkSql = "SELECT COUNT(*) FROM checkouts WHERE patron_id = ? AND return_date IS NULL";
    try (PreparedStatement checkStmt = connection.prepareStatement(checkSql)) {
        checkStmt.setInt(1, patronId);
        ResultSet rs = checkStmt.executeQuery();
        if (rs.next() && rs.getInt(1) > 0) {
            System.out.println("Cannot remove patron with active borrowings.");
            return;
        }
    } catch (SQLException e) {
        System.out.println("Error checking patron: " + e.getMessage());
        return;
    }

    // Remove Related Records (Fines, Holds, Checkouts)
    String[] deleteSqls = {
        "DELETE FROM fines WHERE patron_id = ?",
        "DELETE FROM holds WHERE patron_id = ?",
        "DELETE FROM checkouts WHERE patron_id = ?",
        "DELETE FROM patrons WHERE id = ?"
    };
    for (String sql : deleteSqls) {
        try (PreparedStatement stmt = connection.prepareStatement(sql)) {
            stmt.setInt(1, patronId);
            stmt.executeUpdate();
        } catch (SQLException e) {
            System.out.println("Error removing patron data: " + e.getMessage());
            return;
        }
    }
    System.out.println("Patron removed successfully.");
}

   
   

    

    

    
          
    }


